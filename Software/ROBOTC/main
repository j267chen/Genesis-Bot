//all code

void configureAllSensors(){
    sensorType[S1] = sensorEV3_Touch;
    sensorType[S2] = sensorEV3_Ultrasonic;
    sensorType[S3] = sensorEV3_Color;
    sensorType[S4] = sensorEV3_Gyro;
    wait1Msec(50);
    
    SensorMode[S3] = modeEV3Color_Color;
    SensorMode[S4] = modeEV3Gyro_Calibration; 
    wait1Msec(50);

    SensorMode[S4] = modeEV3Gyro_RateAndAngle;
    wait1Msec(50);
}

void goRobot(int motorPower){
    motor[motorA] = motor[motorD] = motorPower;
}

void spinRobot(float angle, int motorPower){
    motorPower = abs(motorPower);
    resetGyro(S4);

    if(angle > 0)
    {
        motor[motorA] = -motorPower;
        motor[motorD] = motorPower;
    }
    else
    {
        motor[motorA] = motorPower;
        motor[motorD] = -motorPower;
    }
    
    while(abs(getGyroDegrees(S4)) < abs(angle)) 
    {}
    goRobot(0);
}

task main(){
    configureAllSensors();

    displayString(2, "Maze Runner")
    displayString(3, "Made by Jason Chen, Zachary Barandino, Eric Mak, and Eric Shaw")
    displayString(5, "Press Enter to start");
    while (!(getButtonPress(ButtonEnter)))
    {}
    while (getButtonPress(ButtonEnter))
    {}

    time1[T1] = 0;

    //version 1 of maze solving: (turn left algorithm)
    bool unsolved = true;
    while (unsolved)
    {
        goRobot(50);
        while (SensorValue[S3] == (int)colorRed)
        {}
        goRobot(0);

        if (SensorValue[S3] == (int)colorGreen)
        {
            unsolved = false;
        }
        spinRobot(90, 25);
    }
    /*
    need to account for gyro inaccuracies
    need to introduce a secondary objective: pick up block and sort it
    
    could introduce a way to recognize turns and adjust accordingly
    could introduce A* algorithm to solve maze
    */

    displayString(5, "Maze Solved!");
    displayString(6, "Time: %f s", time1[T1] / 1000.0 );
    wait1Msec(10000);

    return 0;
}